<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Trading Signals Dashboard - All Binance Pairs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #00d4aa;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 212, 170, 0.3);
        }

        .current-time {
            background: rgba(42, 42, 42, 0.8);
            border: 1px solid #404040;
            border-radius: 10px;
            padding: 10px 20px;
            margin-bottom: 15px;
            display: inline-block;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            color: #00d4aa;
            text-shadow: 0 0 10px rgba(0, 212, 170, 0.3);
        }

        .time-label {
            font-size: 0.8rem;
            color: #888;
            margin-right: 10px;
        }

        .time-value {
            font-weight: bold;
            color: #ffffff;
        }

        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(42, 42, 42, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #404040;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00d4aa;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
        }

        .status {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }

        .status.connected {
            background: rgba(0, 212, 170, 0.2);
            border: 1px solid #00d4aa;
            color: #00d4aa;
        }

        .status.disconnected {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-container {
            position: relative;
            min-width: 300px;
        }

        .search-input {
            width: 100%;
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #404040;
            padding: 12px 45px 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #00d4aa;
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.3);
        }

        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 1.2rem;
        }

        .clear-search {
            position: absolute;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #ff6b6b;
            cursor: pointer;
            font-size: 1rem;
            display: none;
        }

        .filter-select, .sort-select {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #404040;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            min-width: 180px;
            cursor: pointer;
        }

        .filter-select:focus, .sort-select:focus {
            outline: none;
            border-color: #00d4aa;
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.3);
        }

        .quick-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .quick-filter-btn {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #404040;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .quick-filter-btn:hover {
            border-color: #00d4aa;
            background: rgba(0, 212, 170, 0.1);
        }

        .quick-filter-btn.active {
            background: #00d4aa;
            color: #000;
            border-color: #00d4aa;
        }

        .table-container {
            background: rgba(42, 42, 42, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            overflow-x: auto;
            max-height: 80vh;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        th {
            background: linear-gradient(135deg, #333333 0%, #404040 100%);
            color: #00d4aa;
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #00d4aa;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: linear-gradient(135deg, #404040 0%, #505050 100%);
        }

        th:first-child { border-radius: 10px 0 0 0; }
        th:last-child { border-radius: 0 10px 0 0; }

        .sort-arrow {
            margin-left: 5px;
            font-size: 0.8rem;
            opacity: 0.6;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #404040;
            transition: all 0.3s ease;
        }

        tr:hover {
            background: rgba(0, 212, 170, 0.1);
        }

        .symbol {
            font-weight: bold;
            color: #ffffff;
            font-family: 'Courier New', monospace;
        }

        .price {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .signal {
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
            text-transform: uppercase;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .signal.buy {
            background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.4);
        }

        .signal.sell {
            background: linear-gradient(135deg, #ff6b6b 0%, #e55353 100%);
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .signal.hold {
            background: linear-gradient(135deg, #ffd93d 0%, #f39c12 100%);
            color: #2c2c2c;
            box-shadow: 0 4px 15px rgba(255, 217, 61, 0.4);
        }

        .signal.no-movement {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: #ffffff;
        }

        .trade-result {
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            text-align: center;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .trade-result.trade-now {
            background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.4);
            animation: pulse 2s infinite;
        }

        .trade-result.already-long {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .trade-result.already-short {
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }

        .trade-result.dont-trade {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: #ffffff;
        }

        .trade-result.risky-trade {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
            animation: blink 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            25%, 75% { opacity: 0.7; }
        }

        .confidence {
            font-weight: bold;
        }

        .confidence.very-high { color: #00d4aa; }
        .confidence.high { color: #28a745; }
        .confidence.neutral { color: #ffd93d; }
        .confidence.low { color: #ff6b6b; }
        .confidence.no-movement { color: #6c757d; }

        .timestamp {
            font-size: 0.8rem;
            color: #888;
        }

        .flash-green {
            animation: flashGreen 0.5s ease-in-out;
        }

        .flash-red {
            animation: flashRed 0.5s ease-in-out;
        }

        @keyframes flashGreen {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(0, 212, 170, 0.3); }
        }

        @keyframes flashRed {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(255, 107, 107, 0.3); }
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #404040;
            border-top: 2px solid #00d4aa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tooltip {
            position: absolute;
            background: #2a2a2a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            z-index: 1000;
            display: none;
            border: 1px solid #404040;
            max-width: 200px;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }

        .pagination button {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #404040;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pagination button:hover:not(:disabled) {
            border-color: #00d4aa;
            background: rgba(0, 212, 170, 0.1);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination .current-page {
            background: #00d4aa;
            color: #000;
            border-color: #00d4aa;
        }

        @media (max-width: 768px) {
            .header h1 { font-size: 2rem; }
            .controls { flex-direction: column; }
            .search-container { min-width: 250px; }
            .filter-select, .sort-select { min-width: 150px; }
            table { font-size: 0.85rem; }
            th, td { padding: 8px 6px; }
            .stats-bar { gap: 15px; }
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .header h1 {
                font-size: 1.8rem;
                margin-bottom: 8px;
            }

            .current-time {
                font-size: 0.9rem;
                padding: 8px 15px;
            }

            .stats-bar {
                gap: 10px;
                margin-bottom: 15px;
            }

            .stat-item {
                padding: 8px 12px;
                min-width: 70px;
            }

            .stat-number {
                font-size: 1.2rem;
            }

            .stat-label {
                font-size: 0.7rem;
            }

            .controls {
                gap: 10px;
                margin-bottom: 20px;
            }

            .search-container {
                min-width: 100%;
                order: -1;
            }

            .filter-select, .sort-select {
                min-width: 120px;
                padding: 10px 12px;
                font-size: 0.9rem;
            }

            .quick-filters {
                justify-content: center;
            }

            .quick-filter-btn {
                padding: 6px 10px;
                font-size: 0.8rem;
            }

            /* Mobile Table Optimizations */
            .table-container {
                padding: 10px;
                max-height: 75vh;
                border-radius: 10px;
            }

            table {
                font-size: 0.75rem;
                min-width: 100%;
            }

            th, td {
                padding: 6px 4px;
                white-space: nowrap;
            }

            th {
                padding: 10px 4px;
                font-size: 0.8rem;
            }

            /* Make specific columns more mobile-friendly */
            .symbol {
                font-size: 0.8rem;
                min-width: 60px;
            }

            .price {
                font-size: 0.8rem;
                min-width: 70px;
            }

            .signal {
                padding: 4px 6px;
                font-size: 0.7rem;
                min-width: 60px;
            }

            .trade-result {
                padding: 4px 6px;
                font-size: 0.7rem;
                min-width: 80px;
            }

            .confidence {
                font-size: 0.8rem;
            }

            .timestamp {
                font-size: 0.7rem;
                min-width: 50px;
            }

            /* Mobile pagination */
            .pagination {
                gap: 5px;
                flex-wrap: wrap;
                margin-top: 15px;
            }

            .pagination button {
                padding: 6px 10px;
                font-size: 0.8rem;
            }

            .pagination select {
                font-size: 0.8rem;
                padding: 6px 8px;
            }

            /* Mobile disclaimer */
            .disclaimer {
                margin: 20px auto;
                padding: 15px;
            }

            .disclaimer h3 {
                font-size: 1rem;
            }

            .disclaimer p {
                font-size: 0.85rem;
            }
        }

        /* Tablet Optimizations */
        @media (min-width: 481px) and (max-width: 768px) {
            .header h1 {
                font-size: 2.2rem;
            }

            .controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .search-container {
                min-width: 280px;
            }

            .filter-select, .sort-select {
                min-width: 160px;
            }

            table {
                font-size: 0.9rem;
            }

            th, td {
                padding: 10px 8px;
            }

            .signal, .trade-result {
                font-size: 0.8rem;
            }
        }

        /* Desktop Optimizations */
        @media (min-width: 1200px) {
            .header h1 {
                font-size: 3rem;
            }

            .table-container {
                max-height: 85vh;
            }

            table {
                font-size: 1rem;
            }

            th, td {
                padding: 15px 12px;
            }

            .signal, .trade-result {
                font-size: 0.9rem;
                padding: 8px 15px;
            }

            .controls {
                max-width: 1200px;
                margin: 0 auto 30px auto;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            th, .quick-filter-btn, .pagination button {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .search-input {
                min-height: 44px;
            }

            .filter-select, .sort-select {
                min-height: 44px;
            }

            /* Larger tap targets for mobile */
            .clear-search {
                width: 44px;
                height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .search-icon {
                font-size: 1.4rem;
            }
        }

        /* Horizontal scroll indicator for mobile tables */
        @media (max-width: 768px) {
            .table-container::after {
                content: "← Swipe to see more columns →";
                display: block;
                text-align: center;
                font-size: 0.7rem;
                color: #888;
                padding: 5px 0;
                border-top: 1px solid #404040;
                margin-top: 10px;
            }

            .table-container {
                position: relative;
            }

            /* Add shadow to indicate scrollable content */
            .table-container {
                background: linear-gradient(90deg, rgba(42, 42, 42, 1) 0%, rgba(42, 42, 42, 0) 10%, rgba(42, 42, 42, 0) 90%, rgba(42, 42, 42, 1) 100%),
                           rgba(42, 42, 42, 0.8);
            }
        }

        /* Loading state optimizations for mobile */
        @media (max-width: 768px) {
            .loading {
                padding: 20px;
                font-size: 0.9rem;
            }

            .spinner {
                width: 16px;
                height: 16px;
            }
        }

        .disclaimer {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid #ff6b6b;
            border-radius: 10px;
            padding: 20px;
            margin: 30px auto;
            max-width: 800px;
            text-align: center;
        }

        .disclaimer h3 {
            color: #ff6b6b;
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .disclaimer p {
            color: #e0e0e0;
            font-size: 0.95rem;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .disclaimer .warning {
            color: #ffd93d;
            font-weight: bold;
            font-size: 1.1rem;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
<div class="header">
    <div class="current-time">
        <span class="time-label">Current Time:</span>
        <span class="time-value" id="currentTime">Loading...</span>
    </div>
    <h1>🚀 Complete Binance Crypto Signals</h1>
    <div id="connectionStatus" class="status disconnected">
        <span class="spinner"></span>Loading Binance data...
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            <div class="stat-number" id="totalPairs">0</div>
            <div class="stat-label">Total Pairs</div>
        </div>
        <div class="stat-item">
            <div class="stat-number" id="buySignals">0</div>
            <div class="stat-label">BUY Signals</div>
        </div>
        <div class="stat-item">
            <div class="stat-number" id="sellSignals">0</div>
            <div class="stat-label">SELL Signals</div>
        </div>
        <div class="stat-item">
            <div class="stat-number" id="holdSignals">0</div>
            <div class="stat-label">HOLD Signals</div>
        </div>
    </div>
    </div>

    <div class="controls">
        <div class="search-container">
            <input type="text" id="searchInput" class="search-input"
                   placeholder="Search cryptocurrencies (e.g., BTC, ETH, DOGE)">
            <span class="search-icon">🔍</span>
            <button class="clear-search" id="clearSearch">×</button>
        </div>

        <select id="symbolFilter" class="filter-select">
            <option value="all">All Symbols</option>
            <option value="usdt">USDT Pairs</option>
            <option value="btc">BTC Pairs</option>
            <option value="eth">ETH Pairs</option>
            <option value="bnb">BNB Pairs</option>
            <option value="busd">BUSD Pairs</option>
            <option value="spot">Spot Only</option>
        </select>

        <select id="sortSelect" class="sort-select">
            <option value="volume">Sort by Volume</option>
            <option value="signal">Sort by Signal</option>
            <option value="confidence">Sort by Confidence</option>
            <option value="change">Sort by 24h Change</option>
            <option value="price">Sort by Price</option>
            <option value="symbol">Sort by Symbol</option>
        </select>
    </div>

    <div class="controls">
        <div class="quick-filters">
            <button class="quick-filter-btn" data-filter="buy-only">🟢 BUY Only</button>
            <button class="quick-filter-btn" data-filter="sell-only">🔴 SELL Only</button>
            <button class="quick-filter-btn" data-filter="high-confidence">⭐ High Confidence</button>
            <button class="quick-filter-btn" data-filter="top-volume">📊 Top Volume</button>
            <button class="quick-filter-btn active" data-filter="all">🔄 All</button>
        </div>
    </div>

    <div class="table-container">
        <table id="signalsTable">
            <thead>
            <tr>
                <th data-sort="symbol" title="Trading pair symbol">Symbol <span class="sort-arrow">↕</span></th>
                <th data-sort="price" title="Current market price">Price <span class="sort-arrow">↕</span></th>
                <th data-sort="change" title="24h price change percentage">24h Change <span class="sort-arrow">↕</span>
                </th>
                <th data-sort="volume" title="24h volume in quote currency">Volume <span class="sort-arrow">↕</span>
                </th>
                <th data-sort="signal" title="Trading signal based on technical indicators">Signal <span
                        class="sort-arrow">↕</span></th>
                <th data-sort="confidence" title="Confidence level of the signal">Confidence <span
                        class="sort-arrow">↕</span></th>
                <th data-sort="trade-result" title="Trade recommendation based on current market conditions">Trade
                    Result <span class="sort-arrow">↕</span></th>
                <th data-sort="updated" title="Last update timestamp">Updated <span class="sort-arrow">↕</span></th>
            </tr>
            </thead>
            <tbody id="signalsTableBody">
            <tr>
                <td colspan="8" class="loading">
                    <span class="spinner"></span>Loading all Binance cryptocurrencies...
                </td>
            </tr>
            </tbody>
        </table>
    </div>

    <div class="pagination" id="pagination" style="display: none;">
        <button id="prevPage">← Previous</button>
        <span id="pageInfo">Page 1 of 1</span>
        <button id="nextPage">Next →</button>
        <select id="pageSize">
            <option value="50">50 per page</option>
            <option value="100" selected>100 per page</option>
            <option value="200">200 per page</option>
            <option value="500">500 per page</option>
        </select>
    </div>

    <div id="tooltip" class="tooltip"></div>

<div class="disclaimer">
    <h3>⚠️ Important Disclaimer</h3>
    <p>
        <span class="warning">Must Be Researched By Your Own - Don't Be Bullshit!</span>
    </p>
    <p>
        This trading signal dashboard is generated using real present price data and advanced technical indicators
        including 4EMA (9, 20, 55, 110), AlphaTrend, Enhanced Pivot Points, Bollinger Bands, and Delta Volume Analysis.
        However, all signals are for <strong>educational and informational purposes only</strong>.
    </p>
    <p>
        <strong>DO YOUR OWN RESEARCH:</strong> Past performance does not guarantee future results. Cryptocurrency
        trading involves substantial risk of loss. The market is highly volatile and unpredictable. These signals should
        not be considered as financial advice.
    </p>
    <p>
        <strong>Risk Warning:</strong> Never invest more than you can afford to lose. Always conduct your own analysis
        and consult with qualified financial advisors before making any trading decisions.
    </p>
    <p class="warning">
        Trade Responsibly - Your Capital Is At Risk!
    </p>
</div>

<script>
        class CompleteCryptoDashboard {
            constructor() {
                this.allSymbols = [];
                this.priceData = new Map();
                this.historicalData = new Map();
                this.webSocket = null;
                this.isConnected = false;
                this.updateInterval = null;
                this.currentPage = 1;
                this.pageSize = 100;
                this.currentFilter = 'all';
                this.currentSort = 'volume';
                this.sortDirection = 'desc';
                this.searchTerm = '';
                this.quickFilter = 'all';
                
                this.init();
            }

            async init() {
                await this.loadAllSymbols();
                this.setupWebSocket();
                this.setupEventListeners();
                this.startUpdateLoop();
                this.updateStats();
                this.startClock();
            }

            async loadAllSymbols() {
                try {
                    this.updateConnectionStatus(false, 'Loading all Binance symbols...');
                    
                    const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
                    const data = await response.json();
                    
                    // Get ALL trading symbols (not just USDT pairs)
                    this.allSymbols = data.symbols
                        .filter(symbol => symbol.status === 'TRADING')
                        .map(symbol => ({
                            symbol: symbol.symbol,
                            baseAsset: symbol.baseAsset,
                            quoteAsset: symbol.quoteAsset,
                            isSpotTradingAllowed: symbol.isSpotTradingAllowed
                        }));

                    console.log(`Loaded ${this.allSymbols.length} trading symbols`);
                    document.getElementById('totalPairs').textContent = this.allSymbols.length;
                    
                    await this.loadInitialPrices();
                } catch (error) {
                    console.error('Error loading symbols:', error);
                    this.updateConnectionStatus(false, 'Failed to load symbols');
                }
            }

            async loadInitialPrices() {
                try {
                    this.updateConnectionStatus(false, 'Loading price data...');
                    
                    const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                    const tickers = await response.json();
                    
                    tickers.forEach(ticker => {
                        const symbolData = this.allSymbols.find(s => s.symbol === ticker.symbol);
                        if (symbolData) {
                            this.priceData.set(ticker.symbol, {
                                symbol: ticker.symbol,
                                baseAsset: symbolData.baseAsset,
                                quoteAsset: symbolData.quoteAsset,
                                price: parseFloat(ticker.lastPrice),
                                change: parseFloat(ticker.priceChangePercent),
                                volume: parseFloat(ticker.volume),
                                quoteVolume: parseFloat(ticker.quoteVolume),
                                count: parseInt(ticker.count),
                                lastUpdated: Date.now(),
                                signal: 'HOLD',
                                confidence: 50
                            });
                        }
                    });

                    await this.loadSampleHistoricalData();
                    this.calculateAllSignals();
                    this.renderTable();
                    this.updateConnectionStatus(true, `Connected - ${this.priceData.size} pairs loaded`);
                } catch (error) {
                    console.error('Error loading initial prices:', error);
                    this.updateConnectionStatus(false, 'Failed to load price data');
                }
            }

            async loadSampleHistoricalData() {
                this.updateConnectionStatus(false, 'Loading historical data for technical analysis...');
                
                // Load historical data for more symbols in batches
                const allSymbols = Array.from(this.priceData.keys());
                const BATCH_SIZE = 10; // Process 10 symbols at a time
                const MAX_SYMBOLS = 500; // Limit to top 500 by volume for performance
                
                // Sort by volume and take top symbols for historical data
                const topSymbols = allSymbols
                    .map(symbol => ({ symbol, volume: this.priceData.get(symbol)?.quoteVolume || 0 }))
                    .sort((a, b) => b.volume - a.volume)
                    .slice(0, MAX_SYMBOLS)
                    .map(item => item.symbol);

                console.log(`Loading historical data for ${topSymbols.length} top volume symbols`);

                // Process in batches to avoid overwhelming the API
                for (let i = 0; i < topSymbols.length; i += BATCH_SIZE) {
                    const batch = topSymbols.slice(i, i + BATCH_SIZE);
                    
                    // Process batch concurrently
                    const promises = batch.map(symbol => this.loadSymbolHistoricalData(symbol));
                    
                    try {
                        await Promise.allSettled(promises);
                        
                        // Update progress
                        const progress = Math.min(i + BATCH_SIZE, topSymbols.length);
                        this.updateConnectionStatus(false, `Loading historical data... (${progress}/${topSymbols.length})`);
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error('Batch processing error:', error);
                    }
                }

                console.log(`Completed loading historical data for ${this.historicalData.size} symbols`);
            }

            async loadSymbolHistoricalData(symbol) {
                try {
                    const response = await fetch(
                        `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=200`
                    );
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const klines = await response.json();
                    
                    if (klines && klines.length > 0) {
                        const prices = klines.map(k => parseFloat(k[4])); // Close prices
                        const highs = klines.map(k => parseFloat(k[2]));
                        const lows = klines.map(k => parseFloat(k[3]));
                        const volumes = klines.map(k => parseFloat(k[5]));

                        this.historicalData.set(symbol, {
                            prices,
                            highs,
                            lows,
                            volumes
                        });
                    }
                } catch (error) {
                    console.error(`Error loading historical data for ${symbol}:`, error);
                    // Don't throw, just continue with other symbols
                }
            }

            calculateAllSignals() {
                for (const [symbol, data] of this.priceData.entries()) {
                    const analysis = this.calculateTechnicalIndicators(symbol);
                    data.signal = analysis.signal;
                    data.confidence = analysis.confidence;
                    data.tradeResult = analysis.tradeResult;
                }
            }

            setupWebSocket() {
                // Close existing connection if any
                if (this.webSocket) {
                    this.webSocket.close();
                }

                // Get ALL symbols for real-time updates (not just top 100)
                const allSymbols = Array.from(this.priceData.keys());
                
                console.log(`Setting up WebSocket for ${allSymbols.length} symbols`);
                
                // Binance has limits on streams per connection, so we'll use multiple connections
                this.setupMultipleWebSocketConnections(allSymbols);
            }

            setupMultipleWebSocketConnections(symbols) {
                this.webSockets = [];
                const STREAMS_PER_CONNECTION = 200; // Binance limit is around 200-300 streams per connection
                
                // Split symbols into chunks
                const chunks = [];
                for (let i = 0; i < symbols.length; i += STREAMS_PER_CONNECTION) {
                    chunks.push(symbols.slice(i, i + STREAMS_PER_CONNECTION));
                }

                console.log(`Creating ${chunks.length} WebSocket connections for complete coverage`);

                chunks.forEach((chunk, index) => {
                    setTimeout(() => {
                        this.createWebSocketConnection(chunk, index);
                    }, index * 1000); // Stagger connections to avoid overwhelming
                });
            }

            createWebSocketConnection(symbols, connectionIndex) {
                const streams = symbols.map(symbol => 
                    `${symbol.toLowerCase()}@ticker`
                ).join('/');

                const wsUrl = `wss://stream.binance.com:9443/stream?streams=${streams}`;
                const ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log(`WebSocket ${connectionIndex + 1} connected with ${symbols.length} streams`);
                    this.updateConnectionStatus(true, `Real-time updates active (${this.webSockets.length + 1}/${Math.ceil(Array.from(this.priceData.keys()).length / 200)} connections)`);
                };

                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        if (message.data) {
                            this.handlePriceUpdate(message.data);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };

                ws.onclose = () => {
                    console.log(`WebSocket ${connectionIndex + 1} disconnected`);
                    
                    // Reconnect after delay
                    setTimeout(() => {
                        console.log(`Reconnecting WebSocket ${connectionIndex + 1}...`);
                        this.createWebSocketConnection(symbols, connectionIndex);
                    }, 5000 + (connectionIndex * 1000)); // Staggered reconnection
                };

                ws.onerror = (error) => {
                    console.error(`WebSocket ${connectionIndex + 1} error:`, error);
                };

                this.webSockets = this.webSockets || [];
                this.webSockets[connectionIndex] = ws;
            }

            handlePriceUpdate(data) {
                const symbol = data.s;
                const price = parseFloat(data.c);
                const change = parseFloat(data.P);
                const volume = parseFloat(data.v);
                const quoteVolume = parseFloat(data.q);

                const existing = this.priceData.get(symbol);
                if (!existing) return;

                const oldPrice = existing.price;
                const oldSignal = existing.signal;

                existing.price = price;
                existing.change = change;
                existing.volume = volume;
                existing.quoteVolume = quoteVolume;
                existing.lastUpdated = Date.now();
                existing.priceChange = price - oldPrice;

                // Batch signal recalculation for performance
                if (!this.pendingSignalUpdates) {
                    this.pendingSignalUpdates = new Set();
                }
                this.pendingSignalUpdates.add(symbol);

                // Debounce signal calculations to avoid overwhelming the system
                if (!this.signalUpdateTimer) {
                    this.signalUpdateTimer = setTimeout(() => {
                        this.processPendingSignalUpdates();
                    }, 100); // Process every 100ms
                }

                // Update visible row immediately for price changes
                this.updateTableRow(symbol, false);
                
                // Update stats periodically
                if (!this.statsUpdateTimer) {
                    this.statsUpdateTimer = setTimeout(() => {
                        this.updateStats();
                        this.statsUpdateTimer = null;
                    }, 1000); // Update stats every second
                }
            }

            processPendingSignalUpdates() {
                if (!this.pendingSignalUpdates || this.pendingSignalUpdates.size === 0) {
                    this.signalUpdateTimer = null;
                    return;
                }

                const symbolsToUpdate = Array.from(this.pendingSignalUpdates);
                this.pendingSignalUpdates.clear();
                this.signalUpdateTimer = null;

                // Process in small batches to avoid blocking the UI
                const BATCH_SIZE = 10;
                let currentIndex = 0;

                const processBatch = () => {
                    const batch = symbolsToUpdate.slice(currentIndex, currentIndex + BATCH_SIZE);
                    
                    batch.forEach(symbol => {
                        const existing = this.priceData.get(symbol);
                        if (!existing) return;

                        const oldSignal = existing.signal;
                        const analysis = this.calculateTechnicalIndicators(symbol);
                        
                        existing.signal = analysis.signal;
                        existing.confidence = analysis.confidence;
                        existing.tradeResult = analysis.tradeResult;

                        // Update row if signal changed and it's visible
                        if (oldSignal !== existing.signal) {
                            this.updateTableRow(symbol, true);
                        }
                    });

                    currentIndex += BATCH_SIZE;
                    
                    if (currentIndex < symbolsToUpdate.length) {
                        // Continue processing in next frame
                        requestAnimationFrame(processBatch);
                    }
                };

                processBatch();
            }

            calculateTechnicalIndicators(symbol) {
                const historical = this.historicalData.get(symbol);
                const currentData = this.priceData.get(symbol);
                
                if (!historical || !currentData || historical.prices.length < 110) {
                    // Simple signal based on 24h change for symbols without historical data
                    const change = currentData.change;
                    if (change > 5) return { 
                        signal: 'BUY', 
                        confidence: 60 + Math.min(change * 2, 30),
                        tradeResult: this.getTradeResult('BUY', 60 + Math.min(change * 2, 30), currentData.change)
                    };
                    if (change < -5) return { 
                        signal: 'SELL', 
                        confidence: 60 + Math.min(Math.abs(change) * 2, 30),
                        tradeResult: this.getTradeResult('SELL', 60 + Math.min(Math.abs(change) * 2, 30), currentData.change)
                    };
                    return { 
                        signal: 'HOLD', 
                        confidence: 50,
                        tradeResult: this.getTradeResult('HOLD', 50, currentData.change)
                    };
                }

                const prices = historical.prices;
                const highs = historical.highs;
                const lows = historical.lows;
                const volumes = historical.volumes;
                const currentPrice = currentData.price;

                // 4EMA Calculation (9, 20, 55, 110)
                const ema9 = this.calculateEMA(prices, 9);
                const ema20 = this.calculateEMA(prices, 20);
                const ema55 = this.calculateEMA(prices, 55);
                const ema110 = this.calculateEMA(prices, 110);

                // AlphaTrend Calculation
                const alphaTrend = this.calculateAlphaTrend(prices, highs, lows);

                // Enhanced Pivot Points
                const pivotData = this.calculateEnhancedPivotPoints(highs, lows, prices);

                // Bollinger Bands (20-period with 2 std dev)
                const bb = this.calculateBollingerBands(prices, 20);

                // Delta Volume Analysis
                const deltaVolume = this.calculateDeltaVolume(prices, volumes);

                // Signal scoring with all indicators
                let bullishSignals = 0;
                let totalSignals = 0;

                // 4EMA Signal (Price above all EMAs)
                if (currentPrice > ema9 && currentPrice > ema20 && currentPrice > ema55 && currentPrice > ema110) {
                    bullishSignals += 2; // Higher weight for EMA alignment
                } else if (currentPrice < ema9 && currentPrice < ema20 && currentPrice < ema55 && currentPrice < ema110) {
                    bullishSignals -= 2;
                }
                totalSignals += 2;

                // EMA Trend Direction
                if (ema9 > ema20 && ema20 > ema55 && ema55 > ema110) bullishSignals++;
                else if (ema9 < ema20 && ema20 < ema55 && ema55 < ema110) bullishSignals--;
                totalSignals++;

                // AlphaTrend Signal
                if (alphaTrend.direction === 'up' && alphaTrend.confidence > 0.6) {
                    bullishSignals += Math.round(alphaTrend.confidence * 2);
                } else if (alphaTrend.direction === 'down' && alphaTrend.confidence > 0.6) {
                    bullishSignals -= Math.round(alphaTrend.confidence * 2);
                }
                totalSignals += 2;

                // Bollinger Bands Signal
                if (currentPrice > bb.middle) bullishSignals++;
                else if (currentPrice < bb.middle) bullishSignals--;
                totalSignals++;

                // Bollinger Band position
                const bbPosition = (currentPrice - bb.lower) / (bb.upper - bb.lower);
                if (bbPosition > 0.8) bullishSignals -= 1; // Overbought
                else if (bbPosition < 0.2) bullishSignals += 1; // Oversold
                totalSignals++;

                // Pivot Points Signal
                const distanceToSupport = Math.abs(currentPrice - pivotData.support1) / currentPrice;
                const distanceToResistance = Math.abs(currentPrice - pivotData.resistance1) / currentPrice;
                
                if (distanceToSupport < 0.02) bullishSignals++; // Near support
                if (distanceToResistance < 0.02) bullishSignals--; // Near resistance
                if (currentPrice > pivotData.pivot) bullishSignals++;
                else bullishSignals--;
                totalSignals += 2;

                // Delta Volume Signal
                if (deltaVolume.trend === 'positive' && deltaVolume.strength > 0.6) {
                    bullishSignals += Math.round(deltaVolume.strength * 2);
                } else if (deltaVolume.trend === 'negative' && deltaVolume.strength > 0.6) {
                    bullishSignals -= Math.round(deltaVolume.strength * 2);
                }
                totalSignals += 2;

                // Volume momentum
                if (currentData.quoteVolume > 100000) bullishSignals++;
                totalSignals++;

                // 24h change momentum
                if (currentData.change > 3) bullishSignals++;
                else if (currentData.change < -3) bullishSignals--;
                totalSignals++;

                // Calculate final signal
                const bullishRatio = bullishSignals / totalSignals;
                let signal, confidence;

                // Enhanced signal logic
                if (bullishRatio >= 0.75) {
                    signal = 'BUY';
                    confidence = 75 + (bullishRatio - 0.75) * 100;
                } else if (bullishRatio <= 0.25) {
                    signal = 'SELL';
                    confidence = 75 + (0.25 - bullishRatio) * 100;
                } else if (bullishRatio >= 0.6) {
                    signal = 'BUY';
                    confidence = 50 + (bullishRatio - 0.5) * 50;
                } else if (bullishRatio <= 0.4) {
                    signal = 'SELL';
                    confidence = 50 + (0.5 - bullishRatio) * 50;
                } else {
                    signal = 'HOLD';
                    confidence = 40 + bullishRatio * 20;
                }

                const finalConfidence = Math.round(Math.min(confidence, 95));
                const tradeResult = this.getTradeResult(signal, finalConfidence, currentData.change);

                return {
                    signal,
                    confidence: finalConfidence,
                    tradeResult
                };
            }

            calculateAlphaTrend(prices, highs, lows) {
                if (prices.length < 20) return { direction: 'neutral', confidence: 0 };
                
                // Calculate ATR (Average True Range)
                const atr = this.calculateATR(highs, lows, prices, 14);
                const ema21 = this.calculateEMA(prices, 21);
                
                // AlphaTrend calculation
                const currentPrice = prices[prices.length - 1];
                const previousPrice = prices[prices.length - 2];
                
                // Trend strength based on EMA and ATR
                const trendDistance = Math.abs(currentPrice - ema21) / atr;
                const priceVelocity = (currentPrice - previousPrice) / previousPrice;
                
                let direction = 'neutral';
                let confidence = 0;
                
                if (currentPrice > ema21 && priceVelocity > 0) {
                    direction = 'up';
                    confidence = Math.min(trendDistance * 0.3 + Math.abs(priceVelocity) * 100, 1);
                } else if (currentPrice < ema21 && priceVelocity < 0) {
                    direction = 'down';
                    confidence = Math.min(trendDistance * 0.3 + Math.abs(priceVelocity) * 100, 1);
                }
                
                return { direction, confidence };
            }

            calculateATR(highs, lows, closes, period) {
                if (highs.length < period + 1) return 1;
                
                const trueRanges = [];
                for (let i = 1; i < highs.length; i++) {
                    const tr1 = highs[i] - lows[i];
                    const tr2 = Math.abs(highs[i] - closes[i - 1]);
                    const tr3 = Math.abs(lows[i] - closes[i - 1]);
                    trueRanges.push(Math.max(tr1, tr2, tr3));
                }
                
                // Calculate average of true ranges
                const recentTR = trueRanges.slice(-period);
                return recentTR.reduce((sum, tr) => sum + tr, 0) / recentTR.length;
            }

            calculateEnhancedPivotPoints(highs, lows, closes) {
                if (highs.length < 20) return { pivot: 0, support1: 0, resistance1: 0 };
                
                // Use recent 20 periods for pivot calculation
                const recentHighs = highs.slice(-20);
                const recentLows = lows.slice(-20);
                const recentCloses = closes.slice(-20);
                
                const high = Math.max(...recentHighs);
                const low = Math.min(...recentLows);
                const close = recentCloses[recentCloses.length - 1];
                
                const pivot = (high + low + close) / 3;
                const support1 = 2 * pivot - high;
                const resistance1 = 2 * pivot - low;
                
                return { pivot, support1, resistance1, high, low };
            }

            calculateDeltaVolume(prices, volumes) {
                if (prices.length < 10 || volumes.length < 10) {
                    return { trend: 'neutral', strength: 0 };
                }
                
                let cumulativeDelta = 0;
                let positiveVolume = 0;
                let negativeVolume = 0;
                
                // Analyze last 10 periods
                for (let i = prices.length - 10; i < prices.length - 1; i++) {
                    const priceChange = prices[i + 1] - prices[i];
                    const volume = volumes[i];
                    
                    if (priceChange > 0) {
                        positiveVolume += volume;
                        cumulativeDelta += volume;
                    } else if (priceChange < 0) {
                        negativeVolume += volume;
                        cumulativeDelta -= volume;
                    }
                }
                
                const totalVolume = positiveVolume + negativeVolume;
                const deltaRatio = totalVolume > 0 ? cumulativeDelta / totalVolume : 0;
                
                let trend = 'neutral';
                let strength = Math.abs(deltaRatio);
                
                if (deltaRatio > 0.1) trend = 'positive';
                else if (deltaRatio < -0.1) trend = 'negative';
                
                return { trend, strength: Math.min(strength, 1) };
            }

            calculateEMA(prices, period) {
                const multiplier = 2 / (period + 1);
                let ema = prices[0];
                
                for (let i = 1; i < prices.length; i++) {
                    ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
                }
                
                return ema;
            }

            calculateBollingerBands(prices, period) {
                const recentPrices = prices.slice(-period);
                const sma = recentPrices.reduce((a, b) => a + b) / period;
                const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
                const stdDev = Math.sqrt(variance);

                return {
                    upper: sma + (stdDev * 2),
                    middle: sma,
                    lower: sma - (stdDev * 2)
                };
            }

            getTradeResult(signal, confidence, change24h) {
                const absChange = Math.abs(change24h);
                
                // Check for extremely high 24h change (risky trade)
                if (absChange > 15) {
                    return {
                        status: 'risky-trade',
                        text: 'Risky Trade'
                    };
                }
                
                // High confidence signals
                if (confidence >= 80) {
                    if (signal === 'BUY') {
                        return {
                            status: 'trade-now',
                            text: 'Trade Now (Long)'
                        };
                    } else if (signal === 'SELL') {
                        return {
                            status: 'trade-now',
                            text: 'Trade Now (Short)'
                        };
                    }
                }
                
                // Medium-high confidence
                if (confidence >= 70) {
                    if (signal === 'BUY') {
                        return {
                            status: 'already-long',
                            text: 'Already Traded Long'
                        };
                    } else if (signal === 'SELL') {
                        return {
                            status: 'already-short',
                            text: 'Already Traded Short'
                        };
                    }
                }
                
                // Low confidence or HOLD signals
                if (confidence < 60 || signal === 'HOLD') {
                    return {
                        status: 'dont-trade',
                        text: "Don't Trade"
                    };
                }
                
                // Default case
                return {
                    status: 'dont-trade',
                    text: "Don't Trade"
                };
            }

            getFilteredAndSortedData() {
                let filtered = Array.from(this.priceData.values());

                // Apply search filter
                if (this.searchTerm) {
                    const search = this.searchTerm.toLowerCase();
                    filtered = filtered.filter(data => 
                        data.symbol.toLowerCase().includes(search) ||
                        data.baseAsset.toLowerCase().includes(search) ||
                        data.quoteAsset.toLowerCase().includes(search)
                    );
                }

                // Apply symbol filter
                switch (this.currentFilter) {
                    case 'usdt':
                        filtered = filtered.filter(d => d.quoteAsset === 'USDT');
                        break;
                    case 'btc':
                        filtered = filtered.filter(d => d.quoteAsset === 'BTC');
                        break;
                    case 'eth':
                        filtered = filtered.filter(d => d.quoteAsset === 'ETH');
                        break;
                    case 'bnb':
                        filtered = filtered.filter(d => d.quoteAsset === 'BNB');
                        break;
                    case 'busd':
                        filtered = filtered.filter(d => d.quoteAsset === 'BUSD');
                        break;
                    case 'spot':
                        filtered = filtered.filter(d => d.quoteAsset === 'USDT' || d.quoteAsset === 'BUSD');
                        break;
                }

                // Apply quick filters
                switch (this.quickFilter) {
                    case 'buy-only':
                        filtered = filtered.filter(d => d.signal === 'BUY');
                        break;
                    case 'sell-only':
                        filtered = filtered.filter(d => d.signal === 'SELL');
                        break;
                    case 'high-confidence':
                        filtered = filtered.filter(d => d.confidence >= 75);
                        break;
                    case 'top-volume':
                        filtered = filtered.sort((a, b) => b.quoteVolume - a.quoteVolume).slice(0, 100);
                        break;
                }

                // Apply sorting
                filtered.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch (this.currentSort) {
                        case 'symbol':
                            aVal = a.symbol;
                            bVal = b.symbol;
                            break;
                        case 'price':
                            aVal = a.price;
                            bVal = b.price;
                            break;
                        case 'change':
                            aVal = a.change;
                            bVal = b.change;
                            break;
                        case 'volume':
                            aVal = a.quoteVolume;
                            bVal = b.quoteVolume;
                            break;
                        case 'signal':
                            const signalOrder = { 'BUY': 3, 'HOLD': 2, 'SELL': 1 };
                            aVal = signalOrder[a.signal] || 0;
                            bVal = signalOrder[b.signal] || 0;
                            break;
                        case 'confidence':
                            aVal = a.confidence;
                            bVal = b.confidence;
                            break;
                        case 'trade-result':
                            const tradeOrder = { 'trade-now': 5, 'already-long': 4, 'already-short': 3, 'risky-trade': 2, 'dont-trade': 1 };
                            aVal = tradeOrder[a.tradeResult?.status] || 0;
                            bVal = tradeOrder[b.tradeResult?.status] || 0;
                            break;
                        case 'updated':
                            aVal = a.lastUpdated;
                            bVal = b.lastUpdated;
                            break;
                        default:
                            aVal = a.quoteVolume;
                            bVal = b.quoteVolume;
                    }

                    if (typeof aVal === 'string') {
                        return this.sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    }
                    
                    return this.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                });

                return filtered;
            }

            renderTable() {
                const tbody = document.getElementById('signalsTableBody');
                const filteredData = this.getFilteredAndSortedData();
                
                const startIndex = (this.currentPage - 1) * this.pageSize;
                const endIndex = startIndex + this.pageSize;
                const pageData = filteredData.slice(startIndex, endIndex);
                
                tbody.innerHTML = '';

                if (pageData.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" class="loading">No cryptocurrencies match your filters</td></tr>';
                    return;
                }

                pageData.forEach(data => {
                    const signalText = this.getSignalText(data.signal, data.confidence);
                    const confidenceLabel = this.getConfidenceLabel(data.confidence);
                    const tradeResult = data.tradeResult || { status: 'dont-trade', text: "Don't Trade" };

                    const row = document.createElement('tr');
                    row.id = `row-${data.symbol}`;
                    
                    row.innerHTML = `
                        <td class="symbol">${data.symbol}</td>
                        <td class="price">${this.formatPrice(data.price)} ${data.quoteAsset}</td>
                        <td style="color: ${data.change >= 0 ? '#00d4aa' : '#ff6b6b'}">${data.change.toFixed(2)}%</td>
                        <td>${this.formatVolume(data.quoteVolume)}</td>
                        <td><span class="signal ${data.signal.toLowerCase()}">${signalText}</span></td>
                        <td class="confidence ${confidenceLabel.toLowerCase().replace(' ', '-')}">${data.confidence}%</td>
                        <td><span class="trade-result ${tradeResult.status}">${tradeResult.text}</span></td>
                        <td class="timestamp">${this.formatTimestamp(data.lastUpdated)}</td>
                    `;

                    tbody.appendChild(row);
                });

                this.updatePagination(filteredData.length);
            }

            updateTableRow(symbol, signalChanged = false) {
                const row = document.getElementById(`row-${symbol}`);
                if (!row) return;

                const data = this.priceData.get(symbol);
                if (!data) return;

                const signalText = this.getSignalText(data.signal, data.confidence);
                const confidenceLabel = this.getConfidenceLabel(data.confidence);
                const tradeResult = data.tradeResult || { status: 'dont-trade', text: "Don't Trade" };

                // Flash effect on price change or signal change
                if (data.priceChange || signalChanged) {
                    const flashClass = signalChanged ? 
                        (data.signal === 'BUY' ? 'flash-green' : 'flash-red') :
                        (data.priceChange > 0 ? 'flash-green' : 'flash-red');
                    
                    row.classList.add(flashClass);
                    setTimeout(() => row.classList.remove(flashClass), 500);
                }

                // Update cells
                row.children[1].textContent = `${this.formatPrice(data.price)} ${data.quoteAsset}`;
                row.children[2].textContent = `${data.change.toFixed(2)}%`;
                row.children[2].style.color = data.change >= 0 ? '#00d4aa' : '#ff6b6b';
                row.children[3].textContent = this.formatVolume(data.quoteVolume);
                row.children[4].innerHTML = `<span class="signal ${data.signal.toLowerCase()}">${signalText}</span>`;
                row.children[5].textContent = `${data.confidence}%`;
                row.children[5].className = `confidence ${confidenceLabel.toLowerCase().replace(' ', '-')}`;
                row.children[6].innerHTML = `<span class="trade-result ${tradeResult.status}">${tradeResult.text}</span>`;
                row.children[7].textContent = this.formatTimestamp(data.lastUpdated);
            }

            updateStats() {
                const stats = { BUY: 0, SELL: 0, HOLD: 0 };
                
                for (const data of this.priceData.values()) {
                    stats[data.signal]++;
                }

                document.getElementById('buySignals').textContent = stats.BUY;
                document.getElementById('sellSignals').textContent = stats.SELL;
                document.getElementById('holdSignals').textContent = stats.HOLD;
            }

            updatePagination(totalItems) {
                const totalPages = Math.ceil(totalItems / this.pageSize);
                const pagination = document.getElementById('pagination');
                
                if (totalPages <= 1) {
                    pagination.style.display = 'none';
                    return;
                }
                
                pagination.style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${this.currentPage} of ${totalPages} (${totalItems} items)`;
                document.getElementById('prevPage').disabled = this.currentPage === 1;
                document.getElementById('nextPage').disabled = this.currentPage === totalPages;
            }

            getSignalText(signal, confidence) {
                if (signal === 'BUY' && confidence >= 75) return 'BUY/LONG';
                if (signal === 'SELL' && confidence >= 75) return 'SELL/SHORT';
                if (signal === 'HOLD') return 'HOLD';
                if (confidence <= 25) return 'No Signal';
                return signal;
            }

            getConfidenceLabel(confidence) {
                if (confidence >= 90) return 'Very High';
                if (confidence >= 75) return 'High';
                if (confidence >= 50) return 'Neutral';
                if (confidence >= 25) return 'Low';
                return 'No Movement';
            }

            formatPrice(price) {
                if (price >= 1000) return price.toFixed(0);
                if (price >= 1) return price.toFixed(2);
                if (price >= 0.01) return price.toFixed(4);
                if (price >= 0.0001) return price.toFixed(6);
                return price.toFixed(8);
            }

            formatVolume(volume) {
                if (volume >= 1e9) return (volume / 1e9).toFixed(1) + 'B';
                if (volume >= 1e6) return (volume / 1e6).toFixed(1) + 'M';
                if (volume >= 1e3) return (volume / 1e3).toFixed(1) + 'K';
                return volume.toFixed(0);
            }

            formatTimestamp(timestamp) {
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                return `${hours}h ago`;
            }

            startClock() {
                const currentTimeElement = document.getElementById('currentTime');
                if (!currentTimeElement) return;
                
                // Function to update the clock
                const updateClock = () => {
                    const now = new Date();
                    
                    // Format date
                    const options = { 
                        weekday: 'short', 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric',
                        timeZoneName: 'short'
                    };
                    const dateStr = now.toLocaleDateString('en-US', options);
                    
                    // Format time
                    const hours = String(now.getHours()).padStart(2, '0');
                    const minutes = String(now.getMinutes()).padStart(2, '0');
                    const seconds = String(now.getSeconds()).padStart(2, '0');
                    const timeStr = `${hours}:${minutes}:${seconds}`;
                    
                    // Combine date and time
                    currentTimeElement.textContent = `${dateStr} • ${timeStr}`;
                };
                
                // Update immediately and then every second
                updateClock();
                setInterval(updateClock, 1000);
            }

            setupEventListeners() {
                // Search functionality
                const searchInput = document.getElementById('searchInput');
                const clearSearch = document.getElementById('clearSearch');
                
                searchInput.addEventListener('input', (e) => {
                    this.searchTerm = e.target.value;
                    clearSearch.style.display = this.searchTerm ? 'block' : 'none';
                    this.currentPage = 1;
                    this.renderTable();
                });

                clearSearch.addEventListener('click', () => {
                    searchInput.value = '';
                    this.searchTerm = '';
                    clearSearch.style.display = 'none';
                    this.renderTable();
                });

                // Filter functionality
                document.getElementById('symbolFilter').addEventListener('change', (e) => {
                    this.currentFilter = e.target.value;
                    this.currentPage = 1;
                    this.renderTable();
                });

                // Sort functionality
                document.getElementById('sortSelect').addEventListener('change', (e) => {
                    this.currentSort = e.target.value;
                    this.renderTable();
                });

                // Table header sorting with touch support
                document.querySelectorAll('th[data-sort]').forEach(th => {
                    const handleSort = () => {
                        const newSort = th.dataset.sort;
                        if (this.currentSort === newSort) {
                            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                        } else {
                            this.currentSort = newSort;
                            this.sortDirection = 'desc';
                        }
                        
                        // Update sort arrows
                        document.querySelectorAll('.sort-arrow').forEach(arrow => arrow.textContent = '↕');
                        th.querySelector('.sort-arrow').textContent = this.sortDirection === 'asc' ? '↑' : '↓';
                        
                        this.renderTable();
                    };

                    // Support both click and touch events
                    th.addEventListener('click', handleSort);
                    th.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handleSort();
                    });
                });

                // Quick filters with touch support
                document.querySelectorAll('.quick-filter-btn').forEach(btn => {
                    const handleFilter = () => {
                        document.querySelectorAll('.quick-filter-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.quickFilter = btn.dataset.filter;
                        this.currentPage = 1;
                        this.renderTable();
                    };

                    btn.addEventListener('click', handleFilter);
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handleFilter();
                    });
                });

                // Pagination with touch support
                const prevBtn = document.getElementById('prevPage');
                const nextBtn = document.getElementById('nextPage');
                
                const handlePrev = () => {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.renderTable();
                    }
                };

                const handleNext = () => {
                    this.currentPage++;
                    this.renderTable();
                };

                prevBtn.addEventListener('click', handlePrev);
                prevBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handlePrev();
                });

                nextBtn.addEventListener('click', handleNext);
                nextBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleNext();
                });

                document.getElementById('pageSize').addEventListener('change', (e) => {
                    this.pageSize = parseInt(e.target.value);
                    this.currentPage = 1;
                    this.renderTable();
                });

                // Enhanced tooltip functionality for mobile
                let tooltipTimeout;
                
                document.addEventListener('mouseover', (e) => {
                    if (e.target.title && !this.isMobile()) {
                        this.showTooltip(e);
                    }
                });

                // Touch and hold for tooltips on mobile
                document.addEventListener('touchstart', (e) => {
                    if (e.target.title && this.isMobile()) {
                        tooltipTimeout = setTimeout(() => {
                            this.showTooltip(e);
                        }, 500); // Show after 500ms touch
                    }
                });

                document.addEventListener('touchend', () => {
                    clearTimeout(tooltipTimeout);
                    this.hideTooltip();
                });

                document.addEventListener('mouseout', () => {
                    this.hideTooltip();
                });

                // Handle viewport changes for mobile optimization
                this.handleViewportChanges();

                // Add swipe gesture support for mobile pagination
                this.addSwipeSupport();
            }

            isMobile() {
                return window.innerWidth <= 768 || ('ontouchstart' in window);
            }

            showTooltip(e) {
                const tooltip = document.getElementById('tooltip');
                tooltip.textContent = e.target.title;
                tooltip.style.display = 'block';
                
                // Position tooltip properly for mobile
                const rect = e.target.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                
                let left = e.pageX + 10;
                let top = e.pageY - 30;
                
                // Adjust position if tooltip would go off screen
                if (left + tooltipRect.width > window.innerWidth) {
                    left = window.innerWidth - tooltipRect.width - 10;
                }
                
                if (top < 0) {
                    top = e.pageY + 20;
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            }

            hideTooltip() {
                document.getElementById('tooltip').style.display = 'none';
            }

            handleViewportChanges() {
                let resizeTimeout;
                
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        // Recalculate table dimensions on resize
                        this.optimizeTableForViewport();
                    }, 250);
                });

                // Handle orientation change on mobile
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.optimizeTableForViewport();
                    }, 500);
                });
            }

            optimizeTableForViewport() {
                const table = document.querySelector('table');
                if (!table) return;

                if (this.isMobile()) {
                    // Optimize for mobile viewing
                    table.style.fontSize = window.innerWidth < 480 ? '0.75rem' : '0.85rem';
                } else {
                    // Reset to desktop styles
                    table.style.fontSize = '';
                }
            }

            addSwipeSupport() {
                if (!this.isMobile()) return;

                let touchStartX = 0;
                let touchEndX = 0;
                
                const tableContainer = document.querySelector('.table-container');
                
                tableContainer.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                });

                tableContainer.addEventListener('touchend', (e) => {
                    touchEndX = e.changedTouches[0].screenX;
                    this.handleSwipeGesture();
                });

                // Only handle horizontal swipes for pagination, not table scrolling
                const handleSwipeGesture = () => {
                    const swipeThreshold = 50;
                    const diff = touchStartX - touchEndX;
                    
                    // Only trigger pagination swipes if table is not horizontally scrolled
                    if (tableContainer.scrollLeft === 0 || 
                        tableContainer.scrollLeft === (tableContainer.scrollWidth - tableContainer.clientWidth)) {
                        
                        if (Math.abs(diff) > swipeThreshold) {
                            if (diff > 0 && this.currentPage > 1) {
                                // Swipe left - previous page
                                this.currentPage--;
                                this.renderTable();
                            } else if (diff < 0) {
                                // Swipe right - next page
                                const totalPages = Math.ceil(this.getFilteredAndSortedData().length / this.pageSize);
                                if (this.currentPage < totalPages) {
                                    this.currentPage++;
                                    this.renderTable();
                                }
                            }
                        }
                    }
                };

                this.handleSwipeGesture = handleSwipeGesture;
            }

            updateConnectionStatus(connected, message) {
                const status = document.getElementById('connectionStatus');
                status.className = `status ${connected ? 'connected' : 'disconnected'}`;
                status.innerHTML = connected ? 
                    `✅ ${message}` : 
                    `<span class="spinner"></span>${message}`;
            }

            startUpdateLoop() {
                // Update timestamps every 5 seconds
                this.timestampInterval = setInterval(() => {
                    document.querySelectorAll('.timestamp').forEach(cell => {
                        const row = cell.parentElement;
                        const symbol = row.children[0].textContent;
                        const data = this.priceData.get(symbol);
                        if (data) {
                            cell.textContent = this.formatTimestamp(data.lastUpdated);
                        }
                    });
                }, 5000);

                // Periodic signal recalculation for symbols without real-time updates
                this.signalRecalculationInterval = setInterval(() => {
                    console.log('Performing periodic signal recalculation...');
                    this.calculateAllSignals();
                    this.updateStats();
                    
                    // Refresh table if needed
                    if (this.shouldRefreshTable()) {
                        this.renderTable();
                    }
                }, 30000); // Every 30 seconds

                // Memory cleanup every 5 minutes
                this.memoryCleanupInterval = setInterval(() => {
                    this.performMemoryCleanup();
                }, 300000); // Every 5 minutes

                // Connection health check every minute
                this.healthCheckInterval = setInterval(() => {
                    this.performHealthCheck();
                }, 60000); // Every minute
            }

            shouldRefreshTable() {
                // Refresh if there are significant changes in signals
                const currentTime = Date.now();
                const lastRefresh = this.lastTableRefresh || 0;
                return (currentTime - lastRefresh) > 60000; // Refresh every minute max
            }

            performMemoryCleanup() {
                console.log('Performing memory cleanup...');
                
                // Clean up old price change data
                for (const [symbol, data] of this.priceData.entries()) {
                    if (data.priceChange !== undefined) {
                        delete data.priceChange; // Remove temporary data
                    }
                }

                // Limit historical data storage for inactive symbols
                if (this.historicalData.size > 600) {
                    const symbolsByVolume = Array.from(this.priceData.entries())
                        .sort((a, b) => b[1].quoteVolume - a[1].quoteVolume)
                        .slice(600) // Keep only top 600
                        .map(entry => entry[0]);
                    
                    symbolsByVolume.forEach(symbol => {
                        this.historicalData.delete(symbol);
                    });
                    
                    console.log(`Cleaned up historical data, now tracking ${this.historicalData.size} symbols`);
                }

                // Force garbage collection if available
                if (window.gc) {
                    window.gc();
                }
            }

            performHealthCheck() {
                const activeConnections = this.webSockets ? this.webSockets.filter(ws => 
                    ws && ws.readyState === WebSocket.OPEN
                ).length : 0;

                const totalConnections = this.webSockets ? this.webSockets.length : 0;
                
                console.log(`Health Check: ${activeConnections}/${totalConnections} WebSocket connections active`);
                
                if (activeConnections < totalConnections * 0.5) {
                    console.log('Too many disconnected WebSockets, reinitializing...');
                    this.setupWebSocket();
                }

                // Update connection status
                if (activeConnections > 0) {
                    this.updateConnectionStatus(true, 
                        `Real-time active (${activeConnections}/${totalConnections} connections, ${this.priceData.size} pairs)`
                    );
                } else {
                    this.updateConnectionStatus(false, 'No active connections - reconnecting...');
                    this.setupWebSocket();
                }
            }

            // Clean up method for when page is closed
            cleanup() {
                // Clear all intervals
                if (this.timestampInterval) clearInterval(this.timestampInterval);
                if (this.signalRecalculationInterval) clearInterval(this.signalRecalculationInterval);
                if (this.memoryCleanupInterval) clearInterval(this.memoryCleanupInterval);
                if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);
                if (this.signalUpdateTimer) clearTimeout(this.signalUpdateTimer);
                if (this.statsUpdateTimer) clearTimeout(this.statsUpdateTimer);

                // Close all WebSocket connections
                if (this.webSockets) {
                    this.webSockets.forEach(ws => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.close();
                        }
                    });
                }

                if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                    this.webSocket.close();
                }
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const dashboard = new CompleteCryptoDashboard();
            
            // Cleanup when page is unloaded
            window.addEventListener('beforeunload', () => {
                dashboard.cleanup();
            });
            
            // Handle visibility changes to pause/resume when tab is hidden
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('Page hidden - reducing update frequency');
                } else {
                    console.log('Page visible - resuming normal updates');
                    dashboard.updateStats();
                }
            });
        });
    </script>
</body>
</html>
